#!/usr/bin/env python3
import argparse
import sys
from amppy.dividers import Divider_split_mass
from amppy.dividers.Divider import get_divider_type_string
from amppy import backends
from amppy.backends.SLURM import SLURM
from simple_term_menu import TerminalMenu
from pathlib import Path
import errno

def config_menu(root_dir: Path):
    if not root_dir.is_dir():
        raise FileNotFoundError(errno.ENOENT, os.strerror(errno.ENOENT), str(path))
    configs = list(root_dir.glob("*.cfg"))
    config_menu_items = ["Cancel"] + [f.name + (" " * (40 - len(f.name))) + ("(fit)" if (f.parent / (f.stem + "::fit_results.txt")).exists() else "  *  ") for f in configs]
    config_menu = TerminalMenu(menu_entries=config_menu_items,
                               title="Select an AmpTools Config File",
                               menu_cursor="> ",
                               menu_cursor_style=("fg_red", "bold"),
                               menu_highlight_style=("bg_black", "fg_green"))
    selection_index = config_menu.show()
    if selection_index == 0:
        print("No config file chosen")
        sys.exit(1)
    else:
        return root_dir / configs[selection_index - 1]


class MainParser(object):

    def __init__(self):
        if len(sys.argv) == 1 or sys.argv[1] == '-h' or sys.argv[1] == '--help':
            self.print_help()
            sys.exit(1)
        if not hasattr(self, sys.argv[1]):
            print(f"Unrecognized command {sys.argv[1]}")
            self.print_help()
            sys.exit(1)
        getattr(self, sys.argv[1])()

    def print_help(self):
        print('''usage: amppy <command> [<args>]

Possible commands include:
    divide      Divide data into bins in a new fit directory
    add         Add a configuration file to an existing fit directory
    fit         Run fits using AmpTools
    bootstrap   Bootstrap existing fits using AmpTools
    plot        Plot results

See 'amppy <command> --help' to read about a specific subcommand''')


    def divide(self):
        parser = argparse.ArgumentParser(prog="amppy divide",
                                         description="Divide data into bins")
        parser.add_argument("config")
        parser.add_argument("-o", "--output", required=True)
        parser.add_argument("--low", type=float)
        parser.add_argument("--high", type=float)
        parser.add_argument("-n", "--nbins", type=int)
        parser.add_argument("-d", "--data")
        parser.add_argument("-g", "--generated")
        parser.add_argument("-a", "--accepted")
        parser.add_argument("-b", "--background")
        parser.add_argument("--data-tree")
        parser.add_argument("--generated-tree")
        parser.add_argument("--accepted-tree")
        parser.add_argument("--background-tree")
        if len(sys.argv) == 2:
            parser.print_help()
            sys.exit(1)
        args = parser.parse_args(sys.argv[2:])
        Divider_split_mass().divide(args.low,
                                    args.high,
                                    args.nbins,
                                    args.output,
                                    args.config,
                                    args.data,
                                    args.generated,
                                    args.accepted,
                                    args.background,
                                    data_tree=args.data_tree,
                                    generated_tree=args.generated_tree,
                                    accepted_tree=args.accepted_tree,
                                    background_tree=args.background_tree)


    def add(self):
        parser = argparse.ArgumentParser(prog="amppy add",
                                         description="Add config file")
        parser.add_argument("config")
        parser.add_argument("-o", "--output", required=True)
        if len(sys.argv) == 2:
            parser.print_help()
            sys.exit(1)
        args = parser.parse_args(sys.argv[2:])
        if get_divider_type_string(args.output) == "mass":
            Divider_split_mass().add_config(args.output, args.config)
        else:
            print("Error in locating bin_info.txt")

    def fit(self):
        def print_help():
            print('''usage: amppy fit <dispatcher> [<args>]

Possible dispatchers include:''')
            longest_name_len = 0
            for dispatcher, desc in backends.dispatcher_descriptions:
                if len(dispatcher) > longest_name_len:
                    longest_name_len = len(dispatcher)
            for dispatcher, desc in backends.dispatcher_descriptions:
                print("    " + dispatcher + (" " * (longest_name_len - len(dispatcher))) + "    " + desc)
            print()
            print("See 'amppy fit <dispatcher> --help' to read about a specific dispatcher")
        if len(sys.argv) == 2:
            print_help()
        else: 
            dispatcher_name = sys.argv[2]
            dispatcher_names = [name for name, desc in backends.dispatcher_descriptions]
            if dispatcher_name in dispatcher_names: 
                i_dispatcher = dispatcher_names.index(dispatcher_name)
                parser = argparse.ArgumentParser(prog=f"amppy fit {dispatcher_name}",
                                                    description=f"Run AmpTools fit with {dispatcher_name}")
                parser.add_argument("directory")
                parser.add_argument("-i", default=1, type=int, metavar="iterations")
                parser.add_argument("-s", default=1, type=int, metavar="seed")
                parser.add_argument("-v", default=1, type=int, choices=[0, 1, 2], metavar="verbosity")
                parser.add_argument("--rerun", action='store_true', help="Rerun the fit (deletes all current fit files for the selected config!)")
                backends.dispatchers[i_dispatcher].add_arguments(parser)
                if len(sys.argv) == 3:
                    parser.print_help()
                    sys.exit(1)
                args = parser.parse_args(sys.argv[3:])
                config = str(config_menu(Path(args.directory).resolve()))
                d = backends.dispatchers[i_dispatcher]()
                d.setup(args.directory, config, args.i, args.s, False, args.v)
                if args.rerun:
                    d.remove_fits()
                d.dispatch(**vars(args))
            else:
                print(f"'{dispatcher_name}' is not a valid dispatcher")
                print()
                print_help()

    def bootstrap(self):
        def print_help():
            print('''usage: amppy bootstrap <dispatcher> [<args>]

Possible dispatchers include:''')
            longest_name_len = 0
            for dispatcher, desc in backends.dispatcher_descriptions:
                if len(dispatcher) > longest_name_len:
                    longest_name_len = len(dispatcher)
            for dispatcher, desc in backends.dispatcher_descriptions:
                print("    " + dispatcher + (" " * (longest_name_len - len(dispatcher))) + "    " + desc)
            print()
            print("See 'amppy bootstrap <dispatcher> --help' to read about a specific dispatcher")
        if len(sys.argv) == 2:
            print_help()
        else: 
            dispatcher_name = sys.argv[2]
            dispatcher_names = [name for name, desc in backends.dispatcher_descriptions]
            if dispatcher_name in dispatcher_names: 
                i_dispatcher = dispatcher_names.index(dispatcher_name)
                parser = argparse.ArgumentParser(prog=f"amppy bootstrap {dispatcher_name}",
                                                    description=f"Bootstrap an AmpTools fit with {dispatcher_name}")
                parser.add_argument("directory")
                parser.add_argument("-i", default=1, type=int, metavar="iterations")
                parser.add_argument("-s", default=1, type=int, metavar="seed")
                parser.add_argument("-v", default=1, type=int, choices=[0, 1, 2], metavar="verbosity")
                parser.add_argument("--rerun", action='store_true', help="Rerun the bootstrap fit (deletes all current bootstrap fit files for the selected config!)")
                backends.dispatchers[i_dispatcher].add_arguments(parser)
                if len(sys.argv) == 3:
                    parser.print_help()
                    sys.exit(1)
                args = parser.parse_args(sys.argv[3:])
                config = str(config_menu(Path(args.directory).resolve()))
                d = backends.dispatchers[i_dispatcher]()
                d.setup(args.directory, config, args.i, args.s, True, args.v)
                if args.rerun:
                    d.remove_fits()
                d.bootstrap_config()
                d.dispatch(**vars(args))
            else:
                print(f"'{dispatcher_name}' is not a valid dispatcher")
                print()
                print_help()





if __name__ == '__main__':
    MainParser()
